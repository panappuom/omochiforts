---
import Layout from "../components/Layout.astro";
import images from "../data/images.json";
import sets from "../data/sets.json";
import cfg from "../config/site.config.json";
 
// slugごとにグループ化して cover を選ぶ（最初の1枚）
const bySlug = new Map();
for (const img of images) {
  if (!bySlug.has(img.slug)) bySlug.set(img.slug, []);
  bySlug.get(img.slug).push(img);
}
const cards = [...bySlug.entries()].map(([slug, arr]) => {
  // ファイル番号順っぽく name でソート（簡易）
  arr.sort((a, b) => a.name.localeCompare(b.name, 'ja'));
  const cover = arr[0];
  const meta = sets[slug] || { title: slug, link: "", tags: [] };
  return {
    slug,
    title: meta.title ?? slug,
    link: meta.link ?? "",
    count: arr.length,
    coverSrc: cover?.s ?? "",  // 無ければ空
  };
});
// 画像一覧用ソート: slug 先頭の数値で「降順」→ 同一slug内は name の数値「昇順」
const imagesSorted = [...images].sort((a, b) => {
  const anum = parseInt((a.slug.split('_')[0] ?? ''), 10);
  const bnum = parseInt((b.slug.split('_')[0] ?? ''), 10);
  if (!Number.isNaN(anum) && !Number.isNaN(bnum) && anum !== bnum) return bnum - anum; // 降順
  if (a.slug !== b.slug) return b.slug.localeCompare(a.slug, 'ja');
  const an = parseInt(a.name, 10);
  const bn = parseInt(b.name, 10);
  if (!Number.isNaN(an) && !Number.isNaN(bn) && an !== bn) return an - bn; // 昇順
  return a.name.localeCompare(b.name, 'ja');
});
// タブ配置（center切替）
const layoutAny = (cfg as any)?.layout as any;
const tabsCenter = layoutAny?.tabs?.align === 'center';
---

<Layout>
  <main class="wrap">
    <h1 class="title">ギャラリー</h1>
    
    <div class="tabwrap">
      <input id="tab-images" type="radio" name="tab" checked />
      <input id="tab-works" type="radio" name="tab" />
      <div class={`tabs ${tabsCenter ? 'center' : ''}`} role="tablist">
        <label for="tab-images" class="tab" role="tab" aria-controls="panel-images">画像</label>
        <label for="tab-works" class="tab" role="tab" aria-controls="panel-works">作品</label>
      </div>
      <div class="panels">
        <section id="panel-images" class="panel images" aria-label="images">
          {/* Greedy用: data-w/h/tags を付与し、カード要素に統一 */}
          <div id="grid-images" class="img-grid" role="list">
            {imagesSorted.map((it) => (
              <div class="card" data-w={it.w} data-h={it.h} data-tags={(it.tags ?? []).join(',')}>
                <img
                  class="img"
                  src={it.s}
                  alt={`${it.slug}/${it.name}`}
                  loading="lazy"
                  decoding="async"
                  width={it.w}
                  height={it.h}
                />
              </div>
            ))}
          </div>
        </section>
        <section id="panel-works" class="panel works" aria-label="works">
          <div id="grid-works" class="grid">
            {cards.map((c) => (
              <a class="card" href={`/work/${c.slug}/`} aria-label={`${c.title} を開く`} data-w="1" data-h="1" data-tags={(sets[c.slug]?.tags ?? []).join(',')}>
                <div class="thumb">
                  {c.coverSrc ? (
                    <img src={c.coverSrc} alt={c.title} loading="lazy" decoding="async" />
                  ) : (
                    <div class="ph" aria-hidden="true"></div>
                  )}
                </div>
                <div class="meta">
                  <div class="name">{c.title}</div>
                  <div class="sub">{c.count} 枚</div>
                </div>
              </a>
            ))}
          </div>
        </section>
      </div>
    </div>
  </main>
  <script is:inline>
    {`
    (() => {
      function setupGreedy(grid){
        if(!grid) return null;
        const styles = () => getComputedStyle(document.documentElement);
        const getGaps = () => {
          const r = styles();
          return { gx: parseFloat(r.getPropertyValue('--gx'))||0, gy: parseFloat(r.getPropertyValue('--gy'))||0 };
        };
        const getCols = () => {
          const cs = getComputedStyle(grid);
          // Prefer multicol metrics
          const cc = parseInt(cs.columnCount);
          if(!Number.isNaN(cc) && cc > 0) return cc;
          const cw = parseFloat(cs.columnWidth);
          if(Number.isFinite(cw) && cw > 0){
            const { gx } = getGaps();
            return Math.max(1, Math.floor((grid.clientWidth + gx) / (cw + gx)));
          }
          // Fallback to grid-template-columns count if present
          const tpl = (cs.gridTemplateColumns || '').trim();
          if(!tpl) return 1;
          return Math.max(1, tpl.split(' ').length || 1);
        };
        const metaH = () => parseFloat(styles().getPropertyValue('--meta-h')) || 0;

        const ALL = Array.from(grid.children);
        let current = ALL.slice();

        const relayout = (items) => {
          const { gx, gy } = getGaps();
          const cols = getCols();
          // Determine column width for estimation
          const cs = getComputedStyle(grid);
          let colW = parseFloat(cs.columnWidth);
          if(!(Number.isFinite(colW) && colW > 0)){
            const W = grid.clientWidth - gx * (cols - 1);
            colW = W / Math.max(1, cols);
          }

          const colHeights = new Array(cols).fill(0);
          const buckets = Array.from({ length: cols }, () => []);

          for (const el of items){
            const w = +el.dataset.w || 1;
            const h = +el.dataset.h || 1;
            const est = (h / w) * colW + metaH();
            let k = 0, minV = colHeights[0];
            for(let i=1;i<cols;i++){ if(colHeights[i] < minV){ k=i; minV=colHeights[i]; } }
            buckets[k].push(el);
            colHeights[k] = minV + est + gy;
          }

          const frag = document.createDocumentFragment();
          for(let c=0;c<cols;c++) for(const el of buckets[c]) frag.appendChild(el);
          grid.appendChild(frag);
        };

        const api = {
          filter(tag){ if(!tag){ current=ALL.slice(); return api; } current = ALL.filter(el => (el.dataset.tags||'').split(',').includes(tag)); return api; },
          random(){ const a=current.slice(); for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } current=a; return api; },
          sortByNewest(){ return api; },
          apply(){ relayout(current); return api; },
          reset(){ current = ALL.slice(); return api; }
        };

        const doLayout = () => api.apply();
        window.addEventListener('load', doLayout);
        new ResizeObserver(() => {
          clearTimeout(grid.__greedy_t);
          grid.__greedy_t = setTimeout(doLayout, 60);
        }).observe(grid);
        return api;
      }

      const apiImages = setupGreedy(document.querySelector('#grid-images') || document.querySelector('.img-grid'));
      window.GREEDY = { images: apiImages };
    })();
    `}
  </script>
</Layout>
