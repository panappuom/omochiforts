---
import Layout from "../components/Layout.astro";
import images from "../data/images.json";
import sets from "../data/sets.json";
import cfg from "../config/site.config.json";

// ヘルパ: 小サイズ画像URL優先（avif→webp）
const imgSmall = (r:any) => r?.sizes?.s?.avif ?? r?.sizes?.s?.webp ?? r?.sizes?.l?.avif ?? r?.sizes?.l?.webp ?? "";

// 画像一覧: 新着順（sortKey 降順）→ id
const imagesSorted = [...(images as any[])].sort((a:any, b:any) => {
  const sa = typeof a.sortKey === 'number' ? a.sortKey : Date.parse(a.createdAt || 0);
  const sb = typeof b.sortKey === 'number' ? b.sortKey : Date.parse(b.createdAt || 0);
  if (sa !== sb) return sb - sa;
  return String(a.id).localeCompare(String(b.id));
});

// 初期表示件数（無限スクロールのサーバーサイド初期バッチ）
const inf = (cfg as any)?.gallery?.infinite as any || {};
const BATCH = Math.max(1, parseInt(inf?.batch) || 60);
const PRE = Math.max(1, parseInt(inf?.preRenderBatches) || 1);
const INITIAL_COUNT = Math.max(1, BATCH * PRE);
const initialImages = imagesSorted.slice(0, INITIAL_COUNT);

// タブ配置（center切替）
const layoutAny = (cfg as any)?.layout as any;
const tabsCenter = layoutAny?.tabs?.align === 'center';
---

<Layout>
  <main class="wrap">
    <h1 class="title">ギャラリー</h1>
    
    <div class="tabwrap">
      <input id="tab-images" type="radio" name="tab" checked />
      <input id="tab-works" type="radio" name="tab" />
      <div class={`tabs ${tabsCenter ? 'center' : ''}`} role="tablist">
        <label for="tab-images" class="tab" role="tab" aria-controls="panel-images">画像</label>
        <label for="tab-works" class="tab" role="tab" aria-controls="panel-works">作品</label>
      </div>
      <div class="panels">
        <section id="panel-images" class="panel images" aria-label="images">
          {/* Greedy用: data-w/h/tags を付与し、カード要素に統一 */}
          <div id="grid-images" class="img-grid" role="list">
            {initialImages.map((it:any) => (
              <div class="card" data-w={it.w} data-h={it.h} data-tags={(it.tags ?? []).join(',')}>
                <img
                  class="img"
                  src={imgSmall(it)}
                  alt={`${it.source}`}
                  loading="lazy"
                  decoding="async"
                  width={it.w}
                  height={it.h}
                />
              </div>
            ))}
            </div>
          <div id="sentinel" aria-hidden="true" style="height:1px"></div>
        </section>
        <section id="panel-works" class="panel works" aria-label="works">
          <div id="grid-works">
            {/* TODO: 作品タブ（works）のUIをここに実装します。現在はスケルトンのみ。 */}
          </div>
        </section>
      </div>
    </div>
  </main>
  <script is:inline>
    (() => {
      // ===== 基本要素 =====
      const grid = document.getElementById('grid-images');
      const sentinel = document.getElementById('sentinel');
      if (!grid || !sentinel) return;
    
      // 既にある枚数（SSR初期表示ぶん）
      let index = grid.querySelectorAll('.card').length;
    
      // 1回に追加する枚数／分割挿入
      const BATCH = 60;
      const CHUNK = 20;
    
      // スクロールルート（タブ内スクロールにも対応）
      const scrollRoot = (() => {
        const panel = document.getElementById('panel-images');
        if (!panel) return null;
        const cs = getComputedStyle(panel);
        return /(auto|scroll)/.test(cs.overflowY) && panel.scrollHeight > panel.clientHeight ? panel : null;
      })();
      const onScrollTarget = scrollRoot || window;
    
      // CSS変数からギャップ／最小幅を読む（なければ既定値）
      function cssNum(varName, fallback){
        const v = parseFloat(getComputedStyle(document.documentElement).getPropertyValue(varName));
        return Number.isFinite(v) ? v : fallback;
      }
      function gaps(){
        return { gx: cssNum('--gx', 12), gy: cssNum('--gy', 10) };
      }
      function minThumb(){
        // スマホ用に @media 側で --min-thumb を切り替えておくと自動で効きます
        return cssNum('--min-thumb', 236);
      }
    
      // 残りスクロール量（下端まで）
      function bottomGap(){
        if (scrollRoot){
          return scrollRoot.scrollHeight - scrollRoot.clientHeight - scrollRoot.scrollTop;
        }
        const doc = document.documentElement;
        return doc.scrollHeight - innerHeight - scrollY;
      }
    
      // ===== 列計算＆配置（厳密Greedy） =====
      let COLS = 0;
      let COL_W = 0;
      let COL_X = [];          // 各列のx座標
      let H = [];              // 各列の累積高さ
    
      function computeCols(containerW){
        const { gx } = gaps();
        // 最小幅＋ギャップで列数を決定
        const cols = Math.max(1, Math.floor((containerW + gx) / (minThumb() + gx)));
        return cols;
      }
    
      function recalcColumns(){
        const W = grid.clientWidth;
        const { gx } = gaps();
        const cols = computeCols(W);
        const W_eff = Math.max(0, W - gx*(cols-1));
        const colW = W_eff / Math.max(1, cols);
    
        const changed = (cols !== COLS) || Math.abs(colW - COL_W) > 0.5;
        COLS = cols;
        COL_W = colW;
        COL_X = Array.from({length: COLS}, (_,i) => Math.round(i*(COL_W + gx)));
        // Hは再配置の前にリセットする
        H = Array.from({length: COLS}, () => 0);
        return changed;
      }
    
      function placeOne(card){
        const { gy } = gaps();
        // 比率は data-w/h または naturalWidth/Height から
        const img = card.querySelector('img');
        const w = parseFloat(card.dataset.w) || (img && img.naturalWidth)  || COL_W;
        const h = parseFloat(card.dataset.h) || (img && img.naturalHeight) || COL_W;
        const ratio = h / Math.max(1, w);
        const ch = Math.round(COL_W * ratio);
    
        // いちばん低い列を探す
        let k = 0, minH = H[0];
        for (let i=1; i<COLS; i++){ if (H[i] < minH){ k = i; minH = H[i]; } }
    
        // 座標を適用
        const x = COL_X[k];
        const y = Math.round(minH);
        const s = card.style;
        s.position = 'absolute';
        s.width = `${COL_W}px`;
        s.transform = `translate(${x}px, ${y}px)`;
    
        H[k] = y + ch + gy;
        return H[k];
      }
    
      function layoutAll(){
        const cards = grid.querySelectorAll('.card');
        const { gy } = gaps();
        H = Array.from({length: COLS}, () => 0);
        let maxH = 0;
        for (const card of cards){ maxH = Math.max(maxH, placeOne(card)); }
        grid.style.position = 'relative';
        grid.style.height = `${Math.max(0, Math.round(maxH - gy))}px`;
      }
    
      // 初期レイアウト
      recalcColumns();
      layoutAll();
    
      // 画像がロードされたら微補正（naturalWidthが入るため）
      grid.addEventListener('load', (e) => {
        const t = e.target;
        if (t && t.tagName === 'IMG') layoutAll();
      }, true);
    
      // リサイズ追従（スロットル）
      let rT;
      const ro = new ResizeObserver(() => {
        clearTimeout(rT);
        rT = setTimeout(() => { recalcColumns(); layoutAll(); }, 50);
      });
      ro.observe(grid);
    
      // ===== 画像インデックス（軽量） =====
      let cache = null; // [{src,w,h,tags?}, ...]
      async function loadIndex(){
        if (cache) return cache;
        try{
          const res = await fetch('/images-index.json', { cache:'no-store' });
          const arr = await res.json();
          cache = Array.isArray(arr) ? arr : [];
        }catch{ cache = []; }
        return cache;
      }
    
      // ===== 追加（増分Greedy：DOMに入れつつ即配置） =====
      function appendItems(items){
        if (!items || !items.length) return;
        let maxH = Math.max(0, ...H);
    
        for(const it of items){
          const card = document.createElement('div');
          card.className = 'card';
          if (it.w) card.dataset.w = String(it.w);
          if (it.h) card.dataset.h = String(it.h);
          if (Array.isArray(it.tags)) card.dataset.tags = it.tags.join(',');
    
          const img = document.createElement('img');
          img.className = 'img';
          img.loading = 'lazy';
          img.decoding = 'async';
          if (it.w) img.width = it.w;
          if (it.h) img.height = it.h;
          img.src = it.src;
          img.alt = '';
    
          card.appendChild(img);
          grid.appendChild(card);              // まずDOMに入れる
          maxH = Math.max(maxH, placeOne(card)); // 即座に座標適用
        }
    
        const { gy } = gaps();
        grid.style.height = `${Math.max(0, Math.round(maxH - gy))}px`;
      }
    
      async function loadMore(){
        const idx = await loadIndex();
        if (index >= idx.length) return;
        const end = Math.min(index + BATCH, idx.length);
    
        const enqueue = (fn) =>
          ('requestIdleCallback' in window)
            ? requestIdleCallback(fn, { timeout: 120 })
            : requestAnimationFrame(fn);
    
        let start = index;
        const step = () => {
          if (start >= end) return;
          const nextEnd = Math.min(start + CHUNK, end);
          appendItems(idx.slice(start, nextEnd));
          start = nextEnd;
          index = nextEnd;
          enqueue(step);
        };
        enqueue(step);
      }
    
      // ===== 無限スクロール（IO + フォールバック） =====
      function needMore(){
        const total = cache ? cache.length : Infinity;
        return index < total && bottomGap() < 1200;
      }
    
      if ('IntersectionObserver' in window){
        const io = new IntersectionObserver((entries) => {
          for (const e of entries) if (e.isIntersecting) loadMore();
        }, { root: scrollRoot || null, rootMargin: '1200px 0px' });
        io.observe(sentinel);
      }
    
      let t;
      onScrollTarget.addEventListener('scroll', () => {
        clearTimeout(t);
        t = setTimeout(() => { if (needMore()) loadMore(); }, 80);
      }, { passive: true });
    
      // 初期がスカスカなら自動で埋める
      window.addEventListener('load', () => {
        let loops = 0;
        const fill = () => {
          if (loops++ > 20 || !needMore()) return;
          loadMore().then(() => requestAnimationFrame(fill));
        };
        requestAnimationFrame(fill);
      });
    })();
    </script>
    
    
    
    
</Layout>
