---
import Layout from "../components/Layout.astro";
import images from "../data/images.json";
import sets from "../data/sets.json";
import cfg from "../config/site.config.json";

// ヘルパ: 小サイズ画像URL優先（avif→webp）
const imgSmall = (r:any) => r?.sizes?.s?.avif ?? r?.sizes?.s?.webp ?? r?.sizes?.l?.avif ?? r?.sizes?.l?.webp ?? "";

// ヘルパ: 擬似スラッグ（source の先頭トークンをグループキーに）
const slugOf = (r:any) => {
  const src = String(r?.source ?? "");
  if (!src) return "misc";
  const base = src.split('/').pop() || src;
  // 例: "A_B_C.png" → "A"
  return base.split('_')[0] || "misc";
};

// グループ化して cover を選ぶ（最初の1枚）。存在しないフィールドは使用しない
const bySlug = new Map<string, any[]>();
for (const img of images as any[]) {
  const slug = slugOf(img);
  if (!bySlug.has(slug)) bySlug.set(slug, []);
  bySlug.get(slug)!.push(img);
}
const cards = [...bySlug.entries()].map(([slug, arr]) => {
  // 並びは sortKey(desc) → id
  arr.sort((a:any, b:any) => {
    const sa = typeof a.sortKey === 'number' ? a.sortKey : Date.parse(a.createdAt || 0);
    const sb = typeof b.sortKey === 'number' ? b.sortKey : Date.parse(b.createdAt || 0);
    if (sa !== sb) return sb - sa;
    return String(a.id).localeCompare(String(b.id));
  });
  const cover = arr[0];
  const meta: any = (sets as any)[slug] || { title: slug, link: "", tags: [] };
  return {
    slug,
    title: meta.title ?? slug,
    link: meta.link ?? "",
    count: arr.length,
    coverSrc: imgSmall(cover),
  };
});

// 画像一覧: 新着順（sortKey 降順）→ id
const imagesSorted = [...(images as any[])].sort((a:any, b:any) => {
  const sa = typeof a.sortKey === 'number' ? a.sortKey : Date.parse(a.createdAt || 0);
  const sb = typeof b.sortKey === 'number' ? b.sortKey : Date.parse(b.createdAt || 0);
  if (sa !== sb) return sb - sa;
  return String(a.id).localeCompare(String(b.id));
});

// 初期表示件数（無限スクロールのサーバーサイド初期バッチ）
const inf = (cfg as any)?.gallery?.infinite as any || {};
const BATCH = Math.max(1, parseInt(inf?.batch) || 60);
const PRE = Math.max(1, parseInt(inf?.preRenderBatches) || 1);
const INITIAL_COUNT = Math.max(1, BATCH * PRE);
const initialImages = imagesSorted.slice(0, INITIAL_COUNT);

// タブ配置（center切替）
const layoutAny = (cfg as any)?.layout as any;
const tabsCenter = layoutAny?.tabs?.align === 'center';
---

<Layout>
  <main class="wrap">
    <h1 class="title">ギャラリー</h1>
    
    <div class="tabwrap">
      <input id="tab-images" type="radio" name="tab" checked />
      <input id="tab-works" type="radio" name="tab" />
      <div class={`tabs ${tabsCenter ? 'center' : ''}`} role="tablist">
        <label for="tab-images" class="tab" role="tab" aria-controls="panel-images">画像</label>
        <label for="tab-works" class="tab" role="tab" aria-controls="panel-works">作品</label>
      </div>
      <div class="panels">
        <section id="panel-images" class="panel images" aria-label="images">
          {/* Greedy用: data-w/h/tags を付与し、カード要素に統一 */}
          <div id="grid-images" class="img-grid" role="list">
            {initialImages.map((it:any) => (
              <div class="card" data-w={it.w} data-h={it.h} data-tags={(it.tags ?? []).join(',')}>
                <img
                  class="img"
                  src={imgSmall(it)}
                  alt={`${it.source}`}
                  loading="lazy"
                  decoding="async"
                  width={it.w}
                  height={it.h}
                />
              </div>
            ))}
            </div>
          <div id="sentinel" aria-hidden="true" style="height:1px"></div>
        </section>
        <section id="panel-works" class="panel works" aria-label="works">
          <div id="grid-works" class="grid">
            {cards.map((c:any) => (
              <a class="card" href={`/work/${c.slug}/`} aria-label={`${c.title} を開く`} data-w="1" data-h="1" data-tags={(((sets as any)[c.slug]?.tags) ?? []).join(',')}>
                <div class="thumb">
                  {c.coverSrc ? (
                    <img src={c.coverSrc} alt={c.title} loading="lazy" decoding="async" />
                  ) : (
                    <div class="ph" aria-hidden="true"></div>
                  )}
                </div>
                <div class="meta">
                  <div class="name">{c.title}</div>
                  <div class="sub">{c.count} 枚</div>
                </div>
              </a>
            ))}
          </div>
        </section>
      </div>
    </div>
  </main>
  <script is:inline>
    // ===== debug logger（1つだけでOK） =====
    window.__DBG = true; // falseにすると静かになります
    const log  = (...a) => { if (window.__DBG) console.log(...a); };
    const warn = (...a) => { if (window.__DBG) console.warn(...a); };
    const err  = (...a) => console.error(...a);
    
    window.addEventListener('error', e => err('[error]', e.message, e.filename, e.lineno));
    window.addEventListener('unhandledrejection', e => err('[promise]', e.reason));
    
    // 起動確認
    log('[boot] gallery inline script running');
    
    // ===== ここから本体 =====
    (() => {
      const BATCH = 60;                 // 1回に追加する枚数（あなたの設定に合わせてOK）
      let index = window.INITIAL_COUNT || 120; // 初期表示枚数（あなたの実装と揃える）
      let cache = null;
    
      const grid = document.getElementById('grid-images');
      const sentinel = document.getElementById('sentinel');
    
      // スクロールしている要素を自動判定（window か #panel-images か）
      const scrollRoot = (() => {
        const panel = document.getElementById('panel-images');
        if (!panel) return null;
        const cs = getComputedStyle(panel);
        const isScrollable = /(auto|scroll)/.test(cs.overflowY) && panel.scrollHeight > panel.clientHeight;
        return isScrollable ? panel : null; // nullならviewport(window)
      })();
    
      function bottomGap(){
        if (scrollRoot){
          return scrollRoot.scrollHeight - scrollRoot.clientHeight - scrollRoot.scrollTop;
        }
        const doc = document.documentElement;
        return doc.scrollHeight - innerHeight - scrollY;
      }
    
      function needMore(){
        const haveMore = index < ((cache && Array.isArray(cache)) ? cache.length : Infinity);
        return haveMore && bottomGap() < 1200;
      }
    
      async function loadIndex(){
        if (cache) return cache;
        try{
          log('[index] fetching /images-index.json ...');
          const res = await fetch('/images-index.json', { cache: 'no-store' });
          cache = await res.json();
          log('[index] loaded entries =', Array.isArray(cache) ? cache.length : '(not array)');
        }catch(e){
          err('[index] fetch failed', e);
          cache = [];
        }
        return cache;
      }
    
      function appendItems(items){
        if(!Array.isArray(items) || items.length===0) return;
        const frag = document.createDocumentFragment();
        for(const it of items){
          const card = document.createElement('div');
          card.className = 'card';
          if (it.w) card.dataset.w = String(it.w);
          if (it.h) card.dataset.h = String(it.h);
          if (Array.isArray(it.tags)) card.dataset.tags = it.tags.join(',');
          const img = document.createElement('img');
          img.className = 'img';
          img.loading = 'lazy';
          img.decoding = 'async';
          if (it.w) img.width = it.w;
          if (it.h) img.height = it.h;
          img.src = it.src;  // images-index.json の src を使用
          img.alt = '';
          card.appendChild(img);
          frag.appendChild(card);
        }
        grid.appendChild(frag); // ← センチネルはgridの外なので常にappendでOK
      }
    
      async function loadMore(){
        const idx = await loadIndex();
        const total = Array.isArray(idx) ? idx.length : 0;
        log('[more] before index =', index, 'total =', total, 'bottomGap =', bottomGap());
        if (!Array.isArray(idx) || index >= total) {
          log('[more] stop: no more data');
          return;
        }
        const next = idx.slice(index, index + BATCH);
        index += next.length;
        appendItems(next);
        log('[more] appended =', next.length, 'after index =', index,
            'cardsInDOM =', document.querySelectorAll('#grid-images .card').length);
        try{ window.GREEDY?.images?.apply?.(); }catch(e){ warn('[more] GREEDY.apply failed', e); }
      }
    
      // センチネル自己診断（gridの外にあるはず）
      log('[sentinel] inGrid =', grid?.contains(sentinel), 'display =', sentinel ? getComputedStyle(sentinel).display : 'N/A');
    
      // IntersectionObserver（root を scrollRoot に合わせる）
      if (sentinel && 'IntersectionObserver' in window){
        let IO_HITS = 0;
        const io = new IntersectionObserver((entries) => {
          for (const e of entries) {
            if (e.isIntersecting) {
              IO_HITS++;
              log('[io] hit #', IO_HITS);
              loadMore();
            }
          }
        }, { root: scrollRoot || null, rootMargin: '1500px 0px' });
        io.observe(sentinel);
      }
    
      // スクロール監視は常時ON（IOが沈黙しても拾う）
      let t;
      (scrollRoot || window).addEventListener('scroll', () => {
        clearTimeout(t);
        t = setTimeout(() => {
          const nm = needMore();
          log('[scroll] needMore =', nm, 'index =', index, 'bottomGap =', bottomGap());
          if (nm) loadMore();
        }, 80);
      }, { passive: true });
    
      // 初期にスカスカなら自動で埋める
      window.addEventListener('load', () => {
        let loops = 0;
        const fill = () => {
          if (loops++ > 20 || !needMore()) return;
          loadMore().then(() => requestAnimationFrame(fill));
        };
        requestAnimationFrame(fill);
      });
    
      // 念のための保険（最大30回/1秒間隔）
      {
        let tries = 0;
        const timer = setInterval(async () => {
          if (!needMore() || tries++ > 30) { clearInterval(timer); return; }
          await loadMore();
        }, 1000);
      }
    })();
    </script>
    
</Layout>
