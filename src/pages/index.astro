---
import Layout from "../components/Layout.astro";
import images from "../data/images.json";
import sets from "../data/sets.json";
import cfg from "../config/site.config.json";

// ヘルパ: 小サイズ画像URL優先（avif→webp）
const imgSmall = (r:any) => r?.sizes?.s?.avif ?? r?.sizes?.s?.webp ?? r?.sizes?.l?.avif ?? r?.sizes?.l?.webp ?? "";

// ヘルパ: 擬似スラッグ（source の先頭トークンをグループキーに）
const slugOf = (r:any) => {
  const src = String(r?.source ?? "");
  if (!src) return "misc";
  const base = src.split('/').pop() || src;
  // 例: "A_B_C.png" → "A"
  return base.split('_')[0] || "misc";
};

// グループ化して cover を選ぶ（最初の1枚）。存在しないフィールドは使用しない
const bySlug = new Map<string, any[]>();
for (const img of images as any[]) {
  const slug = slugOf(img);
  if (!bySlug.has(slug)) bySlug.set(slug, []);
  bySlug.get(slug)!.push(img);
}
const cards = [...bySlug.entries()].map(([slug, arr]) => {
  // 並びは sortKey(desc) → id
  arr.sort((a:any, b:any) => {
    const sa = typeof a.sortKey === 'number' ? a.sortKey : Date.parse(a.createdAt || 0);
    const sb = typeof b.sortKey === 'number' ? b.sortKey : Date.parse(b.createdAt || 0);
    if (sa !== sb) return sb - sa;
    return String(a.id).localeCompare(String(b.id));
  });
  const cover = arr[0];
  const meta: any = (sets as any)[slug] || { title: slug, link: "", tags: [] };
  return {
    slug,
    title: meta.title ?? slug,
    link: meta.link ?? "",
    count: arr.length,
    coverSrc: imgSmall(cover),
  };
});

// 画像一覧: 新着順（sortKey 降順）→ id
const imagesSorted = [...(images as any[])].sort((a:any, b:any) => {
  const sa = typeof a.sortKey === 'number' ? a.sortKey : Date.parse(a.createdAt || 0);
  const sb = typeof b.sortKey === 'number' ? b.sortKey : Date.parse(b.createdAt || 0);
  if (sa !== sb) return sb - sa;
  return String(a.id).localeCompare(String(b.id));
});

// 初期表示件数（無限スクロールのサーバーサイド初期バッチ）
const inf = (cfg as any)?.gallery?.infinite as any || {};
const BATCH = Math.max(1, parseInt(inf?.batch) || 60);
const PRE = Math.max(1, parseInt(inf?.preRenderBatches) || 1);
const INITIAL_COUNT = Math.max(1, BATCH * PRE);
const initialImages = imagesSorted.slice(0, INITIAL_COUNT);

// タブ配置（center切替）
const layoutAny = (cfg as any)?.layout as any;
const tabsCenter = layoutAny?.tabs?.align === 'center';
---

<Layout>
  <main class="wrap">
    <h1 class="title">ギャラリー</h1>
    
    <div class="tabwrap">
      <input id="tab-images" type="radio" name="tab" checked />
      <input id="tab-works" type="radio" name="tab" />
      <div class={`tabs ${tabsCenter ? 'center' : ''}`} role="tablist">
        <label for="tab-images" class="tab" role="tab" aria-controls="panel-images">画像</label>
        <label for="tab-works" class="tab" role="tab" aria-controls="panel-works">作品</label>
      </div>
      <div class="panels">
        <section id="panel-images" class="panel images" aria-label="images">
          {/* Greedy用: data-w/h/tags を付与し、カード要素に統一 */}
          <div id="grid-images" class="img-grid" role="list">
            {initialImages.map((it:any) => (
              <div class="card" data-w={it.w} data-h={it.h} data-tags={(it.tags ?? []).join(',')}>
                <img
                  class="img"
                  src={imgSmall(it)}
                  alt={`${it.source}`}
                  loading="lazy"
                  decoding="async"
                  width={it.w}
                  height={it.h}
                />
              </div>
            ))}
            <div id="sentinel" aria-hidden="true"></div>
          </div>
        </section>
        <section id="panel-works" class="panel works" aria-label="works">
          <div id="grid-works" class="grid">
            {cards.map((c:any) => (
              <a class="card" href={`/work/${c.slug}/`} aria-label={`${c.title} を開く`} data-w="1" data-h="1" data-tags={(((sets as any)[c.slug]?.tags) ?? []).join(',')}>
                <div class="thumb">
                  {c.coverSrc ? (
                    <img src={c.coverSrc} alt={c.title} loading="lazy" decoding="async" />
                  ) : (
                    <div class="ph" aria-hidden="true"></div>
                  )}
                </div>
                <div class="meta">
                  <div class="name">{c.title}</div>
                  <div class="sub">{c.count} 枚</div>
                </div>
              </a>
            ))}
          </div>
        </section>
      </div>
    </div>
  </main>
  <script is:inline>
    {`
    (() => {
      const BATCH = ${'${BATCH}'};
      const INITIAL_COUNT = ${'${INITIAL_COUNT}'};
      let index = INITIAL_COUNT;
      let cache = null; // lazy load client index

      function setupGreedy(grid){
        if(!grid) return null;
        const styles = () => getComputedStyle(document.documentElement);
        const getGaps = () => {
          const r = styles();
          return { gx: parseFloat(r.getPropertyValue('--gx'))||0, gy: parseFloat(r.getPropertyValue('--gy'))||0 };
        };
        const getCols = () => {
          const cs = getComputedStyle(grid);
          // Prefer multicol metrics
          const cc = parseInt(cs.columnCount);
          if(!Number.isNaN(cc) && cc > 0) return cc;
          const cw = parseFloat(cs.columnWidth);
          if(Number.isFinite(cw) && cw > 0){
            const { gx } = getGaps();
            return Math.max(1, Math.floor((grid.clientWidth + gx) / (cw + gx)));
          }
          // Fallback to grid-template-columns count if present
          const tpl = (cs.gridTemplateColumns || '').trim();
          if(!tpl) return 1;
          return Math.max(1, tpl.split(' ').length || 1);
        };
        const metaH = () => parseFloat(styles().getPropertyValue('--meta-h')) || 0;

        const ALL = Array.from(grid.children);
        let current = ALL.slice();

        const relayout = (items) => {
          const { gx, gy } = getGaps();
          const cols = getCols();
          // Determine column width for estimation
          const cs = getComputedStyle(grid);
          let colW = parseFloat(cs.columnWidth);
          if(!(Number.isFinite(colW) && colW > 0)){
            const W = grid.clientWidth - gx * (cols - 1);
            colW = W / Math.max(1, cols);
          }

          const colHeights = new Array(cols).fill(0);
          const buckets = Array.from({ length: cols }, () => []);

          for (const el of items){
            const w = +el.dataset.w || 1;
            const h = +el.dataset.h || 1;
            const est = (h / w) * colW + metaH();
            let k = 0, minV = colHeights[0];
            for(let i=1;i<cols;i++){ if(colHeights[i] < minV){ k=i; minV=colHeights[i]; } }
            buckets[k].push(el);
            colHeights[k] = minV + est + gy;
          }

          const frag = document.createDocumentFragment();
          for(let c=0;c<cols;c++) for(const el of buckets[c]) frag.appendChild(el);
          grid.appendChild(frag);
        };

        const api = {
          filter(tag){ if(!tag){ current=ALL.slice(); return api; } current = ALL.filter(el => (el.dataset.tags||'').split(',').includes(tag)); return api; },
          random(){ const a=current.slice(); for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } current=a; return api; },
          sortByNewest(){ return api; },
          apply(){
            // 追加要素も含めて全面再レイアウト
            const items = Array.from(grid.children).filter(el => el.classList?.contains('card'));
            relayout(items);
            // レイアウト後にセンチネルを末尾へ移動
            const sentinel = document.getElementById('sentinel');
            if (sentinel && sentinel.parentElement === grid) grid.appendChild(sentinel);
            return api;
          },
          reset(){ current = ALL.slice(); return api; }
        };

        const doLayout = () => api.apply();
        window.addEventListener('load', doLayout);
        new ResizeObserver(() => {
          clearTimeout(grid.__greedy_t);
          grid.__greedy_t = setTimeout(doLayout, 60);
        }).observe(grid);
        return api;
      }

      const grid = document.querySelector('#grid-images') || document.querySelector('.img-grid');
      const apiImages = setupGreedy(grid);
      window.GREEDY = { images: apiImages };

      async function loadIndex(){
        if (cache) return cache;
        try{
          const res = await fetch('/images-index.json', { cache: 'no-store' });
          cache = await res.json();
        }catch(e){ cache = []; }
        return cache;
      }

      function appendItems(items){
        if(!Array.isArray(items) || items.length===0) return;
        const frag = document.createDocumentFragment();
        for(const it of items){
          const card = document.createElement('div');
          card.className = 'card';
          if (it.w) card.dataset.w = String(it.w);
          if (it.h) card.dataset.h = String(it.h);
          if (Array.isArray(it.tags)) card.dataset.tags = it.tags.join(',');
          const img = document.createElement('img');
          img.className = 'img';
          img.loading = 'lazy';
          img.decoding = 'async';
          if (it.w) img.width = it.w;
          if (it.h) img.height = it.h;
          img.src = it.src;
          img.alt = '';
          card.appendChild(img);
          frag.appendChild(card);
        }
        const sentinel = document.getElementById('sentinel');
        if (sentinel && sentinel.parentElement === grid) {
          // センチネルの直前に挿入して、常に末尾にセンチネルが来るようにする
          grid.insertBefore(frag, sentinel);
        } else {
          grid.appendChild(frag);
        }
        // 追記後レイアウト更新
        try{ window.GREEDY?.images?.apply(); }catch{}
      }

      async function loadMore(){
        const idx = await loadIndex();
        if (!Array.isArray(idx) || index >= idx.length) return;
        const next = idx.slice(index, index + BATCH);
        index += next.length;
        appendItems(next);
      }

      // IntersectionObserver で無限スクロール
      const sentinel = document.getElementById('sentinel');
      if (sentinel && 'IntersectionObserver' in window){
        const io = new IntersectionObserver((entries) => {
          for(const e of entries){
            if(e.isIntersecting){ loadMore(); }
          }
        }, { rootMargin: '1000px 0px' });
        io.observe(sentinel);
      } else {
        // フォールバック: スクロール末尾近くでロード
        let t;
        window.addEventListener('scroll', () => {
          clearTimeout(t);
          t = setTimeout(() => {
            if ((window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 1200)) loadMore();
          }, 100);
        }, { passive: true });
      }
    })();
    `}
  </script>
</Layout>
